const http = require('http');
const express = require('express');
const authorization = require('../middleware/authorization');
const router = express.Router();
const upload = require('../multerconfig');
const ffmpeg = require('fluent-ffmpeg');
const ffmpegpath = require('@ffmpeg-installer/ffmpeg').path;
ffmpeg.setFfmpegPath(ffmpegpath);

require('dotenv').config();

const { S3Client, GetObjectCommand, PutObjectCommand } = require('@aws-sdk/client-s3');
const RetrieveSecret = require('../configFiles/secrets');
const getParameter = require('../configFiles/parameter');
const { fromIni } = require("@aws-sdk/credential-providers");

// Initialize the S3 client using credentials from the AWS profile
const s3 = new S3Client({
  region: 'ap-southeast-2',
  credentials: fromIni({ profile: 'CAB432-STUDENT-901444280953' })
});


/* Upload video to S3 and save metadata to database. User must be authenticated */
router.post('/:email/upload-video', authorization, async function (req, res, next) {
  try {
    // check if user is authenticated
    if (!req.authenticated) {
      return res.status(401).json({ success: false, message: "You are not authorized to upload video." });
    }

    // Use the Cognito user ID (sub) from the token instead of querying MySQL
    const userID = req.token.sub;

    // Upload the video using multer-s3
    upload(req, res, async (err) => {
      if (err) {
        return res.status(400).json({ success: false, message: err });
      }

      if (!req.file) {
        return res.status(400).json({ success: false, message: 'No file selected' });
      }

      // Video file details are available in req.file, no need for fs.readFileSync
      const videoKey = req.file.key; // The key generated by multer-s3
      const videoUrl = req.file.location; // The URL of the uploaded video in S3

      try {
        // Store video metadata in the database
        const videoMetadata = {
          userID: userID, // Using the Cognito user ID (sub)
          originalName: req.file.originalname,
          fileName: videoKey,
          filePath: videoUrl, // S3 file URL
          fileSize: req.file.size,
          uploadTime: new Date(),
        };

        await req.db.from("videos").insert(videoMetadata);

        // Respond with success and video metadata
        res.status(200).json({
          success: true,
          message: 'Video uploaded and metadata saved successfully!',
          videoUrl
        });
      } catch (dbError) {
        // Handle database or S3 errors
        res.status(500).json({ success: false, message: 'Upload to DB failed', error: dbError.message });
      }
    });
  } catch (err) {
    if (!res.headersSent) {
      console.error('Server error:', err);
      return res.status(500).json({ success: false, message: err.message });
    }
    console.error("Headers already sent, unable to respond with error");
  }
});

function requestTranscoding(videoKey, res) {
  const key = videoKey;
  const payload = JSON.stringify({ key });
  console.log('Payload:', payload);

  const options = {
    hostname: process.env.ALB_addr,
    port: 81,
    path: '/transcode',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(payload),
    },
  };

  const fullUrl = `http://${options.hostname}:${options.port}${options.path}`;
  console.log(`Requesting transcoding at URL: ${fullUrl}`);

  const req = http.request(options, (streamRes) => {
    if (res.headersSent) {
      console.warn('Headers already sent.');
      return;
    }

    if (streamRes.statusCode === 200 && streamRes.headers['content-type'] === 'video/mp4') {
      // Set headers for the response to handle video streaming
      res.writeHead(200, {
        'Content-Type': 'video/mp4',
        'Content-Disposition': 'inline',
        'Accept-Ranges': 'bytes',
      });

      // Stream the response from the transcoding service to the client
      streamRes.pipe(res)
        .on('finish', () => {
          console.log('Streaming complete.');
        })
        .on('error', (err) => {
          console.error('Stream error:', err);
          if (!res.headersSent) {
            res.status(500).send('Error during streaming.');
          }
        });
    } else {
      // Handle unexpected content-type or status code
      console.error('Unexpected response from transcode service:', streamRes.statusCode, streamRes.headers['content-type']);
      if (!res.headersSent) {
        res.status(500).send('Error: Unexpected response from transcode service');
      }
    }
  });

  req.on('error', (error) => {
    console.error('Error contacting transcoding service:', error.message);
    if (!res.headersSent) {
      res.status(500).send('Error contacting transcoding service');
    }
  });

  // Write payload to the request body
  req.write(payload);
  req.end();
}


/* Stream video from S3 using ffmpeg */
router.get('/stream-video/:videoId', async (req, res) => {
  const videoKey = req.params.videoId;
  console.log(videoKey);
  console.log("using api route for streaming video");
  try {
    await requestTranscoding(videoKey,res);
  } catch (error) {
    console.error('Failed to send transcode request:', error);
    res.status(500).json({ error: 'Failed to start transcoding' });
  }
});

/* Retrieve all video metadata */
router.get('/retrieve-videos', function (req, res) {
  req.db.from('videos').select('*')
    .then((rows) => {
      if (rows.length === 0) {
        res.status(404).json({ success: false, message: "No videos found" });
      } else {
        res.status(200).json({ success: true, data: rows });
      }
    })
    .catch((err) => {
      console.error('Error retrieving videos:', err);
      res.status(500).json({ success: false, message: "An error occurred while retrieving videos", error: err });
    });
});

/* Retrieve video metadata by videoID */
router.get('/video-details/:videoID', function (req, res) {
  console.log("test metadata by vidID");
  const videoID = req.params.videoID;
  req.db.from('videos').select('*').where('fileName', '=', videoID)
    .then((rows) => {
      if (rows.length === 0) {
        res.status(404).json({ success: false, message: "No video found with that ID" });
      } else {
        res.status(200).json({ success: true, data: rows });
      }
    })
    .catch((err) => {
      res.status(500).json({ success: false, message: "An error occurred while retrieving video details", error: err });
    });
});

/* Use YouTube API to retrieve youtube videos */
router.get('/youTubeFeed/:searchItem', async function (req, res) {
  console.log("test youtubefeed");
  const searchItem = req.params.searchItem;
  const secret = await RetrieveSecret("n11245409-youtubeAPI");
  const YOUTUBE_API_KEY = secret.youtubeAPIKey;
  const retrievedYouTubeURL = await getParameter("n11245409_YouTubeURL")
  const youTubeURL = retrievedYouTubeURL.replace('${YOUTUBE_API_KEY}', YOUTUBE_API_KEY).replace('${encodeURIComponent(searchItem)}', encodeURIComponent(searchItem));
  try {
    const response = await fetch(
      // use API key
      youTubeURL
    );
    if (!response.ok) {
      res.status(404).json({ success: false, message: "succes"});
      console.log("Failed to fetch recommended videos");
    }
    const data = await response.json();
    res.status(200).json({ success: true, data: data.items });
  } catch (error) {
    console.error('Error fetching videos from YouTube:', error.message);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
});

module.exports = router;
